# study_repo


# 알고리즘

💡 `문제를 해결하기 위한 절차 혹은 방법` or `어떠한 일을 수행하기 위한 단계적인 방법`

> 표현 방법
> 
- 의사코드
- 순서도

> 좋은 알고리즘 ❓
> 
1. 정확성 : 얼마나 정확하게 동작하는가❔ 🌟🌟🌟🌟
2. 작업량 : 얼마나 적은 연산으로 원하는 결과를  얻어내는가❔🌟🌟🌟 
3. 메모리 사용량 : 얼마나 적은 메모리를 사용하는가❔🌟🌟🌟
4. 단순성 : 얼마나 단순하가❔
5. 최적성 : 더 이상 개선할 여지없이 최적화되었는가❔시

> 시간복잡도 VS 공간복잡도
> 

🔆 시간복잡도 : 연산의 작업량, 수행시간

- 최선의 경우 ( Best )
- 최악의 경우 ( Worst )
    - 빅 오 표기법 사용 ( $O(n)$ )
- 평균적인 경우 ( Average )

☀️ 공간복잡도 :  메모리 사용량

> 반복 VS 재귀
> 

🔆 반복과 재귀는 유사한 작업을 수행할 수 있다.

- 반복문
    - 수행하는 작업이 완료될 때까지 계속!!
    
    ```java
     // 루프 ( for문 / while문 , ( do ~ while ) ) 사용
    
    // ********** 를 콘솔에 출력하시오.
    for( int i = 0; i < 10; i++ ) {
    	System.out.print("*");
    }
    ```
    
- 재귀
    - “자신을 통해서 자신을 정의한다.!!”
    - 주어진 문제의 해를  구하기 위해 동일하면서 더 작은 문제의 해를 이용하는 방법
    - `함수 내부`에서 직접 혹은 간접적으로 `자기 자신을 호출`하는 함수
    
    ---
    ```
    💡 Tip 💡
    
    1. 함수에 대한 정의를 명확히 해라!! ( what =⇒ 문제를 명확히 정의 )
    2. “Flat” 하게 보아라!! ( 평평하게 로직을 바라보기 )
        
        ⇒ 일단 먼저 처리해야 하는 일을 정의해서 차근차근!!
        
    3. 재귀를 실행을 결정하는 요인(값)은 매개변수로 설정해준다.!!
    ```
    ### 시간적으로 보는 재귀 함수!!
    ![recursive_function.png](..%2FUsers%2Fqlwms%2FDownloads%2Frecursive_function.png)
     ----

    ```
     ❗❗ 주의사항 ❗❗
    
     1. 참조함수 호출은 프로그램 메모리 구조에서 `스택` 을 사용함!!
     2. 재귀호출은 반복적으로 스택의 사용을 의미 ⇒ 메모리 및 속도에서 `성능저하`가 발생한다.
    
     🗯️반드시 기저조건(종료부분)이 존재해야한다. 🗯️
    ```

  🔒 팩토리얼 ⇒ 자신보다 작은 모든 양의 정수들의 곱

> 재귀를 연습하자
>
1. 1차원 배열의 모든 원소 출력을 재귀로 작성해보자.
2. n개 중 k개를 뽑는 조합의 경우의 수 계산을 재귀로 작성해보자

> 재귀가 좋을까❓ 반복문이 좋을까❓
>

🗨️ 어느것이 좋은것은 없다. 반복문으로도 해결이 가능하다.

단, 추상 자료형( List, Tree 등 ) 의 알고리즘 설계를 할 때는 재귀로 하는 것이 자연스러운 경우가 많다.!!

❗재귀로 구현을 하면 `함수호출을 하는 것이기 때문에 스택을 많이 사용하게 된다.` 즉, 메모리를 반복문에 비해서 비교적 많이 사용한다는 점을 기억하자.

|  | 재귀 | 반복 |
| --- | --- | --- |
| 종료 | 재귀 함수 호출이 종료되는 베이스 케이스(base case) ⇒ 기저조건 충족 시 | 반복문의 종료 조건 충족 시 |
| 수행 시간 | (상대적) 느림 | 빠름 |
| 메모리 공간 | (상대적) 많이 사용  | 적게 사용 |
| 소스 코드 길이 | 짧고 간결 | 길다, 복잡 |
| 소스 코드 형태 | 선택 구조 | 반복 구조 |
| 무한 반복시 | 스택 오버플로우 | CPU를 반복해서 점유( 무한 루프 ) |

💡 반복문을 재귀로 바꾸는 연습을 많이 하면 좋을 것 같다. ( 강사님 의견 )

> 피보나치 수열
>

🗨️ 이전 두 수의 합이 다음 항으로 하는 수열

- $F(n) = F(n-1) + F(n-2)$ 관계가 성립하는 수

![Fibonaci.drawio.png](..%2FUsers%2Fqlwms%2FDownloads%2FFibonaci.drawio.png)

위와 같이 피보나치 수를 구하는 함수를 재귀를 돌리게 되면 `중복 호출` 이 발생하는 문제가 생긴다.
그렇게되면 `메모리` 와 `속도` 측면에서 기하급수적으로 커져서 문제를 해결할 수 없다.

그런 문제를 해결하기 위한 방법으로 대표적으로 `메모이제이션(Memoization)` 이 있다.

❗중복 호출이 생긴다면 `메모이제이션` 같은 방법을 생각하자!!